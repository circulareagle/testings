<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Caption Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Bangers&family=Roboto+Mono:wght@700&display=swap');
        
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: white; }
        
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }

        #video-canvas {
            max-width: 100%;
            height: auto;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            background: #000;
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .gradient-text {
            background: linear-gradient(90deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <header class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
            <div>
                <h1 class="text-3xl font-extrabold gradient-text">AI Video Caption Pro</h1>
                <p class="text-slate-400 text-sm">Professional captions with Gemini AI</p>
            </div>
            <div class="flex items-center gap-3">
                <input type="password" id="api-key" placeholder="Gemini API Key" class="bg-slate-800 border border-slate-700 px-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 w-64">
                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-400 hover:text-blue-300 text-xs flex items-center gap-1">
                    Get Key <i data-lucide="external-link" class="w-3 h-3"></i>
                </a>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Left: Video Preview & Controls -->
            <div class="lg:col-span-8 space-y-6">
                <div class="relative group">
                    <canvas id="video-canvas"></canvas>
                    <div id="upload-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/80 rounded-12 cursor-pointer border-2 border-dashed border-slate-700 hover:border-blue-500 transition-all">
                        <i data-lucide="clapperboard" class="w-16 h-16 text-slate-500 mb-4"></i>
                        <p class="text-lg font-semibold">Drop Video or Click to Upload</p>
                        <p class="text-slate-400 text-sm mt-1">MP4, WebM recommended</p>
                        <input type="file" id="video-input" class="hidden" accept="video/*">
                    </div>
                </div>

                <!-- Video Timeline -->
                <div class="bg-slate-800 p-4 rounded-xl border border-slate-700">
                    <div class="flex items-center gap-4 mb-2">
                        <button id="play-btn" class="p-2 hover:bg-slate-700 rounded-full transition-colors disabled:opacity-50">
                            <i data-lucide="play" class="w-6 h-6 fill-current"></i>
                        </button>
                        <span id="timestamp" class="text-xs font-mono text-slate-400">00:00 / 00:00</span>
                        <input type="range" id="seek-bar" class="flex-grow accent-blue-500 h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer" value="0" step="0.01">
                    </div>
                </div>

                <!-- Style Selector -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <button onclick="setStyle('hormozi')" class="style-btn bg-slate-800 border-2 border-slate-700 p-3 rounded-xl hover:border-blue-500 transition-all text-center">
                        <span class="block text-xl font-black text-yellow-400 uppercase font-[Bangers]">POPUP</span>
                        <span class="text-[10px] text-slate-400">Hormozi Style</span>
                    </button>
                    <button onclick="setStyle('classic')" class="style-btn bg-slate-800 border-2 border-slate-700 p-3 rounded-xl hover:border-blue-500 transition-all text-center">
                        <span class="block text-xl font-semibold text-white">Classic</span>
                        <span class="text-[10px] text-slate-400">Cinematic</span>
                    </button>
                    <button onclick="setStyle('neon')" class="style-btn bg-slate-800 border-2 border-slate-700 p-3 rounded-xl hover:border-blue-500 transition-all text-center">
                        <span class="block text-xl font-bold text-cyan-400" style="text-shadow: 0 0 5px #22d3ee;">NEON</span>
                        <span class="text-[10px] text-slate-400">Gaming/Vlog</span>
                    </button>
                    <button onclick="setStyle('netflix')" class="style-btn bg-slate-800 border-2 border-slate-700 p-3 rounded-xl hover:border-blue-500 transition-all text-center">
                        <span class="block text-xl font-bold bg-black text-white px-1">NETFLIX</span>
                        <span class="text-[10px] text-slate-400">Documentary</span>
                    </button>
                </div>
            </div>

            <!-- Right: Subtitles Editor -->
            <div class="lg:col-span-4 flex flex-col h-[600px] bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                    <h2 class="font-bold flex items-center gap-2"><i data-lucide="list-music" class="w-4 h-4"></i> Captions</h2>
                    <button id="generate-btn" class="bg-blue-600 hover:bg-blue-500 px-3 py-1.5 rounded-lg text-xs font-bold transition-all flex items-center gap-2 disabled:bg-slate-700">
                        <i data-lucide="sparkles" class="w-3 h-3"></i> Auto Generate
                    </button>
                </div>

                <div id="captions-list" class="flex-grow overflow-y-auto p-4 space-y-3 custom-scrollbar">
                    <div class="text-center py-20 text-slate-500">
                        <i data-lucide="message-square" class="w-12 h-12 mx-auto mb-2 opacity-20"></i>
                        <p class="text-sm">Upload a video and click<br>Auto Generate to start</p>
                    </div>
                </div>

                <div class="p-4 bg-slate-900/50 border-t border-slate-700">
                    <button id="export-btn" class="w-full bg-green-600 hover:bg-green-500 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                        <i data-lucide="download" class="w-5 h-5"></i> Export Video
                    </button>
                    <p class="text-[10px] text-center text-slate-500 mt-2 italic">Rendering happens locally in your browser</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Video & Audio Elements for Processing -->
    <video id="hidden-video" class="hidden"></video>
    <audio id="hidden-audio" class="hidden"></audio>

    <script>
        // --- Initialization ---
        lucide.createIcons();
        
        const videoInput = document.getElementById('video-input');
        const uploadOverlay = document.getElementById('upload-overlay');
        const canvas = document.getElementById('video-canvas');
        const ctx = canvas.getContext('2d');
        const hiddenVideo = document.getElementById('hidden-video');
        const playBtn = document.getElementById('play-btn');
        const seekBar = document.getElementById('seek-bar');
        const timestamp = document.getElementById('timestamp');
        const generateBtn = document.getElementById('generate-btn');
        const captionsList = document.getElementById('captions-list');
        const exportBtn = document.getElementById('export-btn');

        let captions = [];
        let currentStyle = 'hormozi';
        let isPlaying = false;

        // --- Video Handling ---
        uploadOverlay.addEventListener('click', () => videoInput.click());
        
        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                hiddenVideo.src = url;
                uploadOverlay.classList.add('hidden');
                hiddenVideo.load();
            }
        });

        hiddenVideo.addEventListener('loadedmetadata', () => {
            canvas.width = hiddenVideo.videoWidth;
            canvas.height = hiddenVideo.videoHeight;
            seekBar.max = hiddenVideo.duration;
            updateTimestamp();
            drawFrame();
        });

        function updateTimestamp() {
            const cur = formatTime(hiddenVideo.currentTime);
            const total = formatTime(hiddenVideo.duration);
            timestamp.innerText = `${cur} / ${total}`;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // --- Playback Loop ---
        playBtn.addEventListener('click', () => {
            if (hiddenVideo.paused) {
                hiddenVideo.play();
                playBtn.innerHTML = `<i data-lucide="pause" class="w-6 h-6 fill-current"></i>`;
            } else {
                hiddenVideo.pause();
                playBtn.innerHTML = `<i data-lucide="play" class="w-6 h-6 fill-current"></i>`;
            }
            lucide.createIcons();
        });

        hiddenVideo.addEventListener('timeupdate', () => {
            seekBar.value = hiddenVideo.currentTime;
            updateTimestamp();
            drawFrame();
        });

        seekBar.addEventListener('input', () => {
            hiddenVideo.currentTime = seekBar.value;
            drawFrame();
        });

        function drawFrame() {
            ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
            renderCaptions();
        }

        // --- Caption Styling Engine ---
        const styles = {
            hormozi: {
                font: 'bold 48px Bangers',
                color: '#fbbf24',
                stroke: '#000',
                strokeWidth: 8,
                yPos: 0.8,
                uppercase: true,
                effect: 'pop'
            },
            classic: {
                font: '32px Inter',
                color: '#ffffff',
                stroke: '#000000',
                strokeWidth: 4,
                yPos: 0.85,
                uppercase: false
            },
            neon: {
                font: 'italic bold 44px "Roboto Mono"',
                color: '#22d3ee',
                shadow: '0 0 15px #22d3ee',
                yPos: 0.75,
                uppercase: true
            },
            netflix: {
                font: '30px Inter',
                color: '#ffffff',
                bg: 'rgba(0,0,0,0.7)',
                yPos: 0.85,
                uppercase: false
            }
        };

        function setStyle(s) {
            currentStyle = s;
            drawFrame();
        }

        function renderCaptions() {
            const time = hiddenVideo.currentTime;
            const active = captions.find(c => time >= c.start && time <= c.end);
            if (!active) return;

            const config = styles[currentStyle];
            const text = config.uppercase ? active.text.toUpperCase() : active.text;
            
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = config.font.replace(/\d+px/, (match) => {
                const size = parseInt(match);
                return (size * (canvas.width / 1080)) + 'px'; // Responsive font
            });

            const x = canvas.width / 2;
            const y = canvas.height * config.yPos;

            // Background box (Netflix Style)
            if (config.bg) {
                const metrics = ctx.measureText(text);
                const pad = 20;
                ctx.fillStyle = config.bg;
                ctx.fillRect(x - metrics.width / 2 - pad, y - 30, metrics.width + pad * 2, 60);
            }

            // Outline (Hormozi/Classic)
            if (config.stroke) {
                ctx.strokeStyle = config.stroke;
                ctx.lineWidth = config.strokeWidth || 4;
                ctx.strokeText(text, x, y);
            }

            // Shadow/Glow (Neon)
            if (config.shadow) {
                ctx.shadowColor = config.color;
                ctx.shadowBlur = 15;
            }

            ctx.fillStyle = config.color;
            ctx.fillText(text, x, y);
            ctx.restore();
        }

        // --- AI Auto Generation (Gemini) ---
        generateBtn.addEventListener('click', async () => {
            const apiKey = document.getElementById('api-key').value;
            if (!apiKey) {
                showToast("Please enter a Gemini API Key first!", "error");
                return;
            }
            if (!videoInput.files[0]) {
                showToast("Upload a video first!", "error");
                return;
            }

            try {
                generateBtn.disabled = true;
                generateBtn.innerHTML = `<div class="loader"></div> Generating...`;
                
                // 1. Extract Audio from Video
                const audioBlob = await extractAudio(videoInput.files[0]);
                const base64Audio = await blobToBase64(audioBlob);

                // 2. Call Gemini
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: "Transcribe this audio into a JSON array of objects. Each object MUST have 'start' (float seconds), 'end' (float seconds), and 'text' (string). Break phrases into small chunks of 3-5 words for high-impact social media style captions." },
                                { inlineData: { mimeType: 'audio/wav', data: base64Audio } }
                            ]
                        }],
                        generationConfig: {
                            responseMimeType: "application/json"
                        }
                    })
                });

                const data = await response.json();
                const rawText = data.candidates[0].content.parts[0].text;
                captions = JSON.parse(rawText);
                
                renderCaptionsList();
                showToast("Captions generated successfully!", "success");

            } catch (err) {
                console.error(err);
                showToast("Error generating captions. Check API key/Network.", "error");
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = `<i data-lucide="sparkles" class="w-3 h-3"></i> Auto Generate`;
                lucide.createIcons();
            }
        });

        async function extractAudio(videoFile) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await videoFile.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            
            // Convert to a simple WAV for API (simplified implementation)
            return bufferToWav(audioBuffer);
        }

        function bufferToWav(abuffer) {
            let numOfChan = abuffer.numberOfChannels,
                length = abuffer.length * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16); // 16-bit
            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // chunk length

            for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

            while(pos < length) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                    view.setInt16(pos, sample, true);
                    pos += 2;
                }
                offset++;
            }
            return new Blob([buffer], {type: "audio/wav"});
        }

        function blobToBase64(blob) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.readAsDataURL(blob);
            });
        }

        function renderCaptionsList() {
            captionsList.innerHTML = captions.map((cap, idx) => `
                <div class="bg-slate-700/50 p-3 rounded-lg border border-slate-600 hover:border-blue-500 group transition-all cursor-pointer" onclick="hiddenVideo.currentTime = ${cap.start}">
                    <div class="flex justify-between items-start mb-1">
                        <span class="text-[10px] font-mono text-slate-400">${formatTime(cap.start)} â†’ ${formatTime(cap.end)}</span>
                        <button onclick="deleteCaption(${idx})" class="opacity-0 group-hover:opacity-100 text-slate-400 hover:text-red-400">
                            <i data-lucide="trash-2" class="w-3 h-3"></i>
                        </button>
                    </div>
                    <textarea class="w-full bg-transparent text-sm focus:outline-none resize-none" onchange="updateCaption(${idx}, this.value)">${cap.text}</textarea>
                </div>
            `).join('');
            lucide.createIcons();
        }

        window.updateCaption = (idx, val) => { captions[idx].text = val; drawFrame(); };
        window.deleteCaption = (idx) => { captions.splice(idx, 1); renderCaptionsList(); drawFrame(); };

        // --- Export Logic ---
        exportBtn.addEventListener('click', async () => {
            if (captions.length === 0) return;
            
            exportBtn.disabled = true;
            exportBtn.innerHTML = `<div class="loader"></div> Processing...`;
            
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'captioned_video.webm';
                a.click();
                
                exportBtn.disabled = false;
                exportBtn.innerHTML = `<i data-lucide="download" class="w-5 h-5"></i> Export Video`;
                lucide.createIcons();
            };

            // Reset video to start for recording
            hiddenVideo.pause();
            hiddenVideo.currentTime = 0;
            
            setTimeout(() => {
                recorder.start();
                hiddenVideo.play();
                
                const checkEnd = setInterval(() => {
                    if (hiddenVideo.ended) {
                        recorder.stop();
                        clearInterval(checkEnd);
                        hiddenVideo.pause();
                    }
                }, 500);
            }, 500);
        });

        // --- UI Utilities ---
        function showToast(msg, type) {
            const toast = document.createElement('div');
            toast.className = `fixed bottom-8 left-1/2 -translate-x-1/2 px-6 py-3 rounded-full font-bold shadow-2xl z-50 transition-all ${type === 'error' ? 'bg-red-500' : 'bg-green-500'}`;
            toast.innerText = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
    </script>
</body>
</html>

